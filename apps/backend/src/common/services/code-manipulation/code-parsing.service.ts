import { Injectable, Logger } from '@nestjs/common';
import { GeneratedCode } from '../../../modules/ai/interfaces/ai-agent.interface';

/**
 * Code Parsing Service
 * 
 * Handles parsing of AI-generated code from various formats and structures.
 * Extracts feature files, step definitions, tests, fixtures, schemas, types,
 * and client code from generated text with comprehensive validation and cleaning.
 * 
 * @class CodeParsingService
 */
@Injectable()
export class CodeParsingService {
  private readonly logger = new Logger(CodeParsingService.name);

  /**
   * Parses AI-generated code from text.
   * 
   * @param generatedText - The raw text generated by AI containing code blocks
   * @returns Parsed code object with extracted feature, steps, tests, and other components
   * 
   * @example
   * ```typescript
   * const generatedText = '***Features:***\nScenario: Test\n***Steps:***\nGiven("test", () => {})';
   * const parsedCode = codeParsingService.parseGeneratedCode(generatedText);
   * console.log('Feature:', parsedCode.feature);
   * console.log('Steps:', parsedCode.steps);
   * ```
   */
  parseGeneratedCode(generatedText: string): GeneratedCode {
    this.logger.log(`ðŸ” Parsing generated code...`);
    
    const code: GeneratedCode = {};
    
    // Search for code using specific format ***Features:*** and ***Steps:***
    const featuresMatch = generatedText.match(/\*\*\*Features:\*\*\*([\s\S]*?)(?=\*\*\*Steps:\*\*\*|$)/);
    if (featuresMatch) {
      let featureContent = featuresMatch[1].trim();
      
      // Clean markdown blocks if they exist
      if (featureContent.includes('```gherkin')) {
        const gherkinMatch = featureContent.match(/```gherkin\s*([\s\S]*?)```/);
        if (gherkinMatch) {
          featureContent = gherkinMatch[1].trim();
        }
      } else if (featureContent.includes('```')) {
        const codeMatch = featureContent.match(/```\s*([\s\S]*?)```/);
        if (codeMatch) {
          featureContent = codeMatch[1].trim();
        }
      }
      
      code.feature = featureContent;
      this.logger.log(`âœ… Feature code found (***Features:*** format)`);
      this.logger.log(`ðŸ“„ Feature content (first 200 chars): ${featureContent.substring(0, 200)}...`);
    } else {
      this.logger.log(`âš ï¸ No feature code found with ***Features:*** format`);
    }
    
    const stepsMatch = generatedText.match(/\*\*\*Steps:\*\*\*([\s\S]*?)(?=\*\*\*Features:\*\*\*|$)/);
    if (stepsMatch) {
      let stepsContent = stepsMatch[1].trim();
      
      // Clean markdown blocks if they exist
      if (stepsContent.includes('```typescript')) {
        const typescriptMatch = stepsContent.match(/```typescript\s*([\s\S]*?)```/);
        if (typescriptMatch) {
          stepsContent = typescriptMatch[1].trim();
        }
      } else if (stepsContent.includes('```')) {
        const codeMatch = stepsContent.match(/```\s*([\s\S]*?)```/);
        if (codeMatch) {
          stepsContent = codeMatch[1].trim();
        }
      }
      
      code.steps = stepsContent;
      this.logger.log(`âœ… Steps code found (***Steps:*** format)`);
      this.logger.log(`ðŸ“„ Steps content (first 200 chars): ${stepsContent.substring(0, 200)}...`);
    } else {
      this.logger.log(`âš ï¸ No steps code found with ***Steps:*** format`);
    }
    
    // Validate that feature contains @TC-
    if (code.feature && !code.feature.includes('@TC-')) {
      this.logger.warn(`âš ï¸ Feature code does not contain @TC-: ${code.feature.substring(0, 100)}...`);
    }
    
    // Validate that steps contains Given/When/Then
    if (code.steps) {
      const hasStepDefinition = code.steps.includes('Given(') || code.steps.includes('When(') || code.steps.includes('Then(');
      if (!hasStepDefinition) {
        this.logger.warn(`âš ï¸ Steps code does not contain Given/When/Then definitions: ${code.steps.substring(0, 100)}...`);
      }
    }
    
    // Fallback: search for feature code (multiple formats) if not found with specific format
    if (!code.feature) {
      let featureMatch = generatedText.match(/```gherkin:?([\s\S]*?)```/);
      if (!featureMatch) {
        // Search without markdown blocks, just the scenario
        featureMatch = generatedText.match(/(?:Scenario:|@TC-.*?\nScenario:)([\s\S]*?)(?=\n\n|\n\/\/|\nGiven\(|$)/);
      }
      if (!featureMatch) {
        // Search for any line containing "Scenario:"
        const scenarioLines = generatedText.split('\n').filter(line => line.includes('Scenario:'));
        if (scenarioLines.length > 0) {
          const scenarioIndex = generatedText.indexOf(scenarioLines[0]);
          const nextSection = generatedText.indexOf('\n\n', scenarioIndex);
          const endIndex = nextSection > -1 ? nextSection : generatedText.length;
          code.feature = generatedText.substring(scenarioIndex, endIndex).trim();
          this.logger.log(`âœ… Feature code found (free format)`);
        }
      } else {
        code.feature = featureMatch[1].trim();
        this.logger.log(`âœ… Feature code found (markdown format)`);
      }
      
      // If feature not found, search in complete text
      if (!code.feature) {
        // Search for complete scenario pattern with tags
        const fullScenarioMatch = generatedText.match(/(@\w+[^\n]*\n)*@TC-[^\n]*\nScenario:[^\n]*\n((?:  [^\n]*\n)*)/);
        if (fullScenarioMatch) {
          code.feature = fullScenarioMatch[0].trim();
          this.logger.log(`âœ… Feature code found (complete pattern)`);
        } else {
          this.logger.log(`âš ï¸ No feature code found with expected format`);
        }
      }
    }
    
    // Fallback: search for steps code (multiple formats) if not found with specific format
    if (!code.steps) {
      let stepsMatch = generatedText.match(/```typescript:?([\s\S]*?)```/);
      if (!stepsMatch) {
        // Search without markdown blocks, just the step
        stepsMatch = generatedText.match(/(?:Given\(|When\(|Then\()([\s\S]*?)(?=\n\n|\n\/\/|\nGiven\(|\nWhen\(|\nThen\(|$)/);
      }
      if (!stepsMatch) {
        // Search for any line containing "Given(", "When(", "Then("
        const stepLines = generatedText.split('\n').filter(line => 
          line.includes('Given(') || line.includes('When(') || line.includes('Then(')
        );
        if (stepLines.length > 0) {
          const stepIndex = generatedText.indexOf(stepLines[0]);
          const nextSection = generatedText.indexOf('\n\n', stepIndex);
          const endIndex = nextSection > -1 ? nextSection : generatedText.length;
          code.steps = generatedText.substring(stepIndex, endIndex).trim();
          this.logger.log(`âœ… Steps code found (free format)`);
        }
      } else {
        code.steps = stepsMatch[1].trim();
        this.logger.log(`âœ… Steps code found (markdown format)`);
      }
      
      // If steps not found, search in complete text
      if (!code.steps) {
        // Search for complete step pattern with Given/When/Then
        const fullStepMatch = generatedText.match(/Given\([^)]*\)[^}]*}/);
        if (fullStepMatch) {
          code.steps = fullStepMatch[0].trim();
          this.logger.log(`âœ… Steps code found (complete pattern)`);
        } else {
          this.logger.log(`âš ï¸ No steps code found with expected format`);
        }
      }
    }
    
    // Search for other types of code if necessary
    const testsMatch = generatedText.match(/```javascript:?([\s\S]*?)```/);
    if (testsMatch) {
      code.tests = testsMatch[1].trim();
      this.logger.log(`âœ… Tests code found`);
    }
    
    const fixturesMatch = generatedText.match(/```typescript:?fixtures?([\s\S]*?)```/);
    if (fixturesMatch) {
      code.fixtures = fixturesMatch[1].trim();
      this.logger.log(`âœ… Fixtures code found`);
    }
    
    const schemasMatch = generatedText.match(/```typescript:?schemas?([\s\S]*?)```/);
    if (schemasMatch) {
      code.schemas = schemasMatch[1].trim();
      this.logger.log(`âœ… Schemas code found`);
    }
    
    const typesMatch = generatedText.match(/```typescript:?types?([\s\S]*?)```/);
    if (typesMatch) {
      code.types = typesMatch[1].trim();
      this.logger.log(`âœ… Types code found`);
    }
    
    const clientMatch = generatedText.match(/```typescript:?client?([\s\S]*?)```/);
    if (clientMatch) {
      code.client = clientMatch[1].trim();
      this.logger.log(`âœ… Client code found`);
    }
    
    this.logger.log(`ðŸ“‹ Parsed code: ${JSON.stringify(code, null, 2)}`);
    
    return code;
  }

  /**
   * Validates that the parsed code is valid.
   * 
   * @param code - The parsed code object to validate
   * @returns Validation result with success status and error messages
   * 
   * @example
   * ```typescript
   * const parsedCode = { feature: 'Scenario: Test', steps: 'Given("test", () => {})' };
   * const validation = codeParsingService.validateParsedCode(parsedCode);
   * if (!validation.isValid) {
   *   console.log('Validation errors:', validation.errors);
   * }
   * ```
   */
  validateParsedCode(code: GeneratedCode): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Verify that we have at least feature or steps
    if (!code.feature && !code.steps) {
      errors.push('No feature or steps code found');
    }
    
    // Validate feature structure if it exists
    if (code.feature) {
      const featureErrors = this.validateFeatureCode(code.feature);
      errors.push(...featureErrors);
    }
    
    // Validate steps structure if it exists
    if (code.steps) {
      const stepsErrors = this.validateStepsCode(code.steps);
      errors.push(...stepsErrors);
    }
    
    return { isValid: errors.length === 0, errors };
  }

  /**
   * Validates feature code structure.
   * 
   * @private
   * @param featureCode - The feature code to validate
   * @returns Array of validation error messages
   */
  private validateFeatureCode(featureCode: string): string[] {
    const errors: string[] = [];
    const lines = featureCode.split('\n');
    
    let hasScenario = false;
    let hasGiven = false;
    let hasWhen = false;
    let hasThen = false;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith('Scenario:')) {
        hasScenario = true;
      } else if (trimmedLine.startsWith('Given')) {
        hasGiven = true;
      } else if (trimmedLine.startsWith('When')) {
        hasWhen = true;
      } else if (trimmedLine.startsWith('Then')) {
        hasThen = true;
      }
    }
    
    if (!hasScenario) {
      errors.push('Feature does not contain scenarios');
    }
    
    if (!hasGiven) {
      errors.push('Feature does not contain Given steps');
    }
    
    if (!hasWhen) {
      errors.push('Feature does not contain When steps');
    }
    
    if (!hasThen) {
      errors.push('Feature does not contain Then steps');
    }
    
    return errors;
  }

  /**
   * Validates steps code structure.
   * 
   * @private
   * @param stepsCode - The steps code to validate
   * @returns Array of validation error messages
   */
  private validateStepsCode(stepsCode: string): string[] {
    const errors: string[] = [];
    const lines = stepsCode.split('\n');
    
    let hasGiven = false;
    let hasWhen = false;
    let hasThen = false;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith('Given(')) {
        hasGiven = true;
      } else if (trimmedLine.startsWith('When(')) {
        hasWhen = true;
      } else if (trimmedLine.startsWith('Then(')) {
        hasThen = true;
      }
    }
    
    if (!hasGiven && !hasWhen && !hasThen) {
      errors.push('Steps does not contain Given, When or Then definitions');
    }
    
    return errors;
  }

  /**
   * Cleans generated code by removing unnecessary lines.
   * 
   * @param code - The generated code object to clean
   * @returns Cleaned code object with unnecessary lines removed
   * 
   * @example
   * ```typescript
   * const dirtyCode = { feature: '  \nScenario: Test\n  ', steps: '// steps/file.ts\nGiven("test", () => {})' };
   * const cleanCode = codeParsingService.cleanGeneratedCode(dirtyCode);
   * ```
   */
  cleanGeneratedCode(code: GeneratedCode): GeneratedCode {
    const cleanedCode: GeneratedCode = {};
    
    for (const [key, value] of Object.entries(code)) {
      if (value) {
        cleanedCode[key as keyof GeneratedCode] = this.removeUnnecessaryLines(value);
      }
    }
    
    return cleanedCode;
  }

  /**
   * Removes unnecessary lines from code.
   * 
   * @private
   * @param code - The code string to clean
   * @returns Cleaned code string
   */
  private removeUnnecessaryLines(code: string): string {
    const lines = code.split('\n');
    const cleanedLines: string[] = [];
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Skip empty lines at beginning and end
      if (trimmedLine === '' && (cleanedLines.length === 0 || cleanedLines[cleanedLines.length - 1] === '')) {
        continue;
      }
      
      // Skip file comments
      if (trimmedLine.startsWith('// features/') || trimmedLine.startsWith('// steps/')) {
        continue;
      }
      
      cleanedLines.push(line);
    }
    
    // Remove empty lines at the end
    while (cleanedLines.length > 0 && cleanedLines[cleanedLines.length - 1].trim() === '') {
      cleanedLines.pop();
    }
    
    return cleanedLines.join('\n');
  }

  /**
   * Extracts information from parsed code.
   * 
   * @param code - The parsed code object to analyze
   * @returns Information object with presence flags and total line count
   * 
   * @example
   * ```typescript
   * const parsedCode = { feature: 'Scenario: Test', steps: 'Given("test", () => {})' };
   * const info = codeParsingService.extractCodeInfo(parsedCode);
   * console.log(`Has feature: ${info.hasFeature}, Total lines: ${info.totalLines}`);
   * ```
   */
  extractCodeInfo(code: GeneratedCode): {
    hasFeature: boolean;
    hasSteps: boolean;
    hasTests: boolean;
    hasFixtures: boolean;
    hasSchemas: boolean;
    hasTypes: boolean;
    hasClient: boolean;
    totalLines: number;
  } {
    const info = {
      hasFeature: !!code.feature,
      hasSteps: !!code.steps,
      hasTests: !!code.tests,
      hasFixtures: !!code.fixtures,
      hasSchemas: !!code.schemas,
      hasTypes: !!code.types,
      hasClient: !!code.client,
      totalLines: 0,
    };
    
    let totalLines = 0;
    for (const value of Object.values(code)) {
      if (value) {
        totalLines += value.split('\n').length;
      }
    }
    
    info.totalLines = totalLines;
    
    return info;
  }
} 